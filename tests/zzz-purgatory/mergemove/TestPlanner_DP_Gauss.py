
import numpy as np
import unittest

from bnpy import HModel
from bnpy.util.RandUtil import mvnrand
from bnpy.data import XData

from bnpy.mergemove import MergePlanner

KWARGS = dict(
  randstate=np.random.RandomState(42),
  mergePerLap=1000,
  preselectroutine='random',
  returnScoreMatrix=1,
  )

def listAllPairs(K):
  L = list()
  for kA in xrange(K):
    for kB in xrange(kA+1, K):
      L.append((kA, kB))
  return L


class DPGaussTestBase(unittest.TestCase):
  __test__ = False # Do not execute this abstract module!

  def MakeModelWithTrueComps(self):
    ''' Create hmodel with "true" components as self.Data, add to self
        Also create representative suff stats SS, add to self
    '''
    aDict = dict(alpha0=1.0, truncType='z')
    oDict = dict(kappa=1e-5, dF=1, ECovMat='eye', sF=1e-3)
    self.hmodel = HModel.CreateEntireModel('VB', 'DPMixModel', 'Gauss', 
                                           aDict, oDict, self.Data)

    LP = dict(resp=self.TrueResp)
    SS = self.hmodel.get_global_suff_stats(self.Data, LP)
    for _ in range(3):
      self.hmodel.update_global_params(SS)
      LP = self.hmodel.calc_local_params(self.Data)
      SS = self.hmodel.get_global_suff_stats(self.Data, LP, doPrecompEntropy=1)
    self.SS = SS

  def MakeModelWithDuplicatedComps(self):
    ''' Create model with "duplicated" components"
          For each true component k, we have "two" versions of it, k1 and k2.
            Half of the data generated by k is assigned to k1 
            and the other half is assigned to k2.
          These assignments are done via "dupResp" local parameter,
            and so by feeding that LP into SS and update_global_params.
    '''
    aDict = dict(alpha0=1.0, truncType='z')
    oDict = dict(kappa=1e-5, dF=1, ECovMat='eye', sF=1e-3)
    self.dupModel = HModel.CreateEntireModel('VB', 'DPMixModel', 'Gauss',
                                             aDict, oDict, self.Data)

    LP = dict(resp=self.DupResp)
    SS = self.dupModel.get_global_suff_stats(self.Data, LP)
    for _ in range(3):
      self.dupModel.update_global_params(SS)
      LP = self.dupModel.calc_local_params(self.Data)
      SS = self.dupModel.get_global_suff_stats(self.Data, LP,
                                               doPrecompEntropy=1)
    self.dupSS = SS


  def MakeModelWithJunkComps(self):
    ''' Create model with "junk" components. 
        These have some bare-minimum mass, but aren't very useful.
    '''
    aDict = dict(alpha0=1.0, truncType='z')
    oDict = dict(kappa=1e-5, dF=1, ECovMat='eye', sF=1e-3)
    self.junkModel = HModel.CreateEntireModel('VB', 'DPMixModel', 'Gauss',
                                             aDict, oDict, self.Data)

    LP = dict(resp=self.JunkResp)
    SS = self.junkModel.get_global_suff_stats(self.Data, LP)
    for _ in range(3):
      self.junkModel.update_global_params(SS)
      LP = self.junkModel.calc_local_params(self.Data)
      SS = self.junkModel.get_global_suff_stats(self.Data, LP,
                                               doPrecompEntropy=1)
    self.junkSS = SS

class AbstractTest(DPGaussTestBase):
  __test__ = False # Do not execute this abstract module!

  def shortDescription(self):
    return None

  def setUp(self):
    self.MakeData()
    self.MakeModelWithTrueComps()
    self.MakeModelWithDuplicatedComps()
    self.MakeModelWithJunkComps()

    self.CandidatePairs_True = listAllPairs(self.SS.K)
    self.CandidatePairs_Dup = listAllPairs(self.dupSS.K)
    self.CandidatePairs_Junk = listAllPairs(self.junkSS.K)

    assert np.abs(self.TrueResp.sum() - self.Data.nObs) < 1e-4
    assert np.abs(self.DupResp.sum() - self.Data.nObs) < 1e-4
    assert np.abs(self.JunkResp.sum() - self.Data.nObs) < 1e-4

  ######################################################### True Model Tests
  def test__True__random(self):
    kwargs = dict(**KWARGS)
    kwargs['preselectroutine'] = 'random'
    mPairs, M = MergePlanner.preselect_candidate_pairs(self.hmodel, 
                                                       self.SS,        
                                                       **kwargs)
    assert len(mPairs) == len(self.CandidatePairs_True)
    assert M.shape == (self.SS.K, self.SS.K)

  def test__True__marglik(self):
    kwargs = dict(**KWARGS)
    kwargs['preselectroutine'] = 'random'
    mPairs, M = MergePlanner.preselect_candidate_pairs(self.hmodel, 
                                                       self.SS,        
                                                       **kwargs)
    assert len(mPairs) == len(self.CandidatePairs_True)
    assert M.shape == (self.SS.K, self.SS.K)
    print ''
    print M
    print mPairs

  def test__True__obsmodelELBO(self):
    kwargs = dict(**KWARGS)
    kwargs['preselectroutine'] = 'obsmodelELBO'
    mPairs, M = MergePlanner.preselect_candidate_pairs(self.hmodel, 
                                                       self.SS,        
                                                       **kwargs)
    assert len(mPairs) == 0
    assert M.shape == (self.SS.K, self.SS.K)
    print ''
    print M
    print mPairs

  ######################################################### Dup Model Tests
  def test__Dup__random(self):
    kwargs = dict(**KWARGS)
    kwargs['preselectroutine'] = 'random'
    mPairs, M = MergePlanner.preselect_candidate_pairs(self.dupModel, 
                                                       self.dupSS,        
                                                       **kwargs)
    assert len(mPairs) == len(self.CandidatePairs_Dup)
    assert M.shape == (self.dupSS.K, self.dupSS.K)

  def test__Dup__marglik(self):
    kwargs = dict(**KWARGS)
    kwargs['preselectroutine'] = 'marglik'
    mPairs, M = MergePlanner.preselect_candidate_pairs(self.dupModel, 
                                                       self.dupSS,        
                                                       **kwargs)
    assert len(mPairs) == len(self.CandidatePairs_Dup)
    assert M.shape == (self.dupSS.K, self.dupSS.K)
    print ''
    print M
    print mPairs

  def test__Dup__obsmodelELBO(self):
    kwargs = dict(**KWARGS)
    kwargs['preselectroutine'] = 'obsmodelELBO'
    mPairs, M = MergePlanner.preselect_candidate_pairs(self.dupModel, 
                                                       self.dupSS,        
                                                       **kwargs)
    assert M.shape == (self.dupSS.K, self.dupSS.K)
    print ''
    print M
    print mPairs

  ######################################################### Junk Model Tests
  def test__Junk__marglik(self):
    kwargs = dict(**KWARGS)
    kwargs['preselectroutine'] = 'random'
    mPairs, M = MergePlanner.preselect_candidate_pairs(self.junkModel, 
                                                       self.junkSS,        
                                                       **kwargs)
    assert len(mPairs) == len(self.CandidatePairs_Junk)
    assert M.shape == (self.junkSS.K, self.junkSS.K)
    print ''
    print M
    print mPairs


  def test__Junk__obsmodelELBO(self):
    kwargs = dict(**KWARGS)
    kwargs['preselectroutine'] = 'obsmodelELBO'
    mPairs, M = MergePlanner.preselect_candidate_pairs(self.junkModel, 
                                                       self.junkSS,   
                                                       **kwargs)

    assert M.shape == (self.junkSS.K, self.junkSS.K)
    print ''
    print M
    print mPairs

########################################################### K=1, D=1
###########################################################
###########################################################

class TestK1D1(AbstractTest):
  __test__ = True

  def MakeData(self, N=10000, Njunk=100):
    ''' Create simple toy XData from standard normal x[n] ~ N(0, 1)
    '''
    PRNG = np.random.RandomState(0)
    X = PRNG.randn(N,1)
    self.Data = XData(X)
    self.Mu = np.zeros(1)
    self.TrueResp = np.ones((N,1))
    self.DupResp = np.zeros((N,2))
    self.DupResp[:N/2,0] = 1
    self.DupResp[N/2:,1] = 1

    self.JunkResp = np.zeros((N,2))
    junkIDs = PRNG.choice( N, Njunk)
    self.JunkResp[:,0] = self.TrueResp[:,0]
    self.JunkResp[junkIDs,0] = 0
    self.JunkResp[junkIDs,1] = 1


########################################################### K=2, D=1
###########################################################
###########################################################

class TestK2D1(AbstractTest):
  __test__ = True

  def MakeData(self, N=10000, Njunk=300):
    ''' Create simple toy XData from standard normal x[n] ~ N(0, 1)
    '''
    self.Mu = np.asarray( [-10, 10] ).T

    PRNG = np.random.RandomState(0)
    X1 = self.Mu[0] + PRNG.randn(N,1)
    X2 = self.Mu[1] + PRNG.randn(N,1)
    X = np.vstack([X1, X2])

    self.Data = XData(X)
    self.TrueResp = np.zeros((2*N,2))
    self.DupResp = np.zeros((2*N,4))
    self.TrueResp[:N,0] = 1
    self.TrueResp[N:,1] = 1
    self.DupResp[:N/2,0] = 1
    self.DupResp[N/2:N,1] = 1
    self.DupResp[N:3*N/2,2] = 1
    self.DupResp[3*N/2:2*N,3] = 1


    self.JunkResp = np.zeros((2*N,4))
    junkIDs = PRNG.choice(N, Njunk) # junk comes only from comp 0!
    junk1 = junkIDs[:Njunk/2]
    junk2 = junkIDs[Njunk/2:]

    self.JunkResp[:,:2] = self.TrueResp
    self.JunkResp[junk1,:] = 0
    self.JunkResp[junk1,2] = 1
    self.JunkResp[junk2,:] = 0
    self.JunkResp[junk2,3] = 1

########################################################### K=8, D=2
###########################################################
###########################################################

class TestAsteriskK8D2(AbstractTest):
  __test__ = True

  def MakeData(self, N=10000, Njunk=500):
    import AsteriskK8
    PRNG = np.random.RandomState(0)

    Data = AsteriskK8.get_data(nObsTotal=N, seed=425)

    self.Data = Data

    self.TrueResp = np.zeros( (N,8))
    self.DupResp = np.zeros( (N,8*2))
    for n in range(Data.nObs):
      k = Data.TrueLabels[n]
      self.TrueResp[n, k] = 1
      self.DupResp[n, k] = 0.5
      self.DupResp[n, k+8] = 0.5

    self.JunkResp = np.zeros((N,9))
    junkIDs = PRNG.choice(N, Njunk) # junk comes only from comp 0!
    self.JunkResp[:,:8] = self.TrueResp
    self.JunkResp[junkIDs, :] = 0
    self.JunkResp[junkIDs, -1] = 1

    # Try two smaller junk components instead
    #self.JunkResp = np.zeros((N,9))
    #junk1 = junkIDs[:Njunk/2]
    #junk2 = junkIDs[Njunk/2:]
    #self.JunkResp[junk1,:] = 0
    #self.JunkResp[junk1,8] = 1
    #self.JunkResp[junk2,:] = 0
    #self.JunkResp[junk2,9] = 1

    assert np.abs(self.TrueResp.sum() - self.Data.nObs) < 1e-4
    assert np.abs(self.DupResp.sum() - self.Data.nObs) < 1e-4